#            label_branch_points = F,
#            graph_label_size = 1, # size of # in circle
#            group_label_size = 3,
#            cell_size = 1,
#            alpha = 0.7,
#            scale_to_range = T)
#
# #### STEP4C: (NOT RUN) MORAN's I Test of Autocorrelation ####
# now we can extrapolate genes that are differentially expressed in this region
# Moran’s I is a measure of multi-directional and multi-dimensional spatial autocorrelation.
# the statistic tells you whether cells at nearby positions on a
# trajectory will have similar (or dissimilar) +
# expression levels for the gene being tested.
## first lets do the whole dataset
# a special gene module score heatmap (for the whole dataset)
# pr_graph_test_res <- graph_test(plaqviewobj.cds, neighbor_graph="principal_graph", cores=2)
# write.csv(pr_graph_test_res, file = "moransI_all_clusters.csv")
# pr_deg_ids <- row.names(subset(pr_graph_test_res, q_value < 0.00000001)) # you can adjust the p-value here
# head(pr_deg_ids)
# gene_module_df <- find_gene_modules(plaqviewobj.cds[pr_deg_ids,], resolution=1e-3)
# cell_group_df <- tibble::tibble(cell=row.names(colData(plaqviewobj.cds)),
#                                 cell_group=colData(plaqviewobj.cds)$assigned_cell_type)
# agg_mat <- aggregate_gene_expression(plaqviewobj.cds, gene_module_df, cell_group_df)
# row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))
# pheatmap::pheatmap(agg_mat,
#                    scale="column", clustering_method="ward.D2")
#
# # which then can be visualized like so;
# # this can show you the different gene modules that can are responsible for changes over pseudotime
# plot_cells(plaqviewobj.cds,
#            genes=gene_module_df %>% filter(module %in% c(2,3,7)), # specify the module you want to examine
#            label_cell_groups=T,
#            show_trajectory_graph=F)
#
# subset(gene_module_df, module == 2)
#
# ## now lets do the subsets
# # pr_graph_test_res.sub <- graph_test(plaqviewobj.cds_subset, neighbor_graph="principal_graph", cores=2)
# pr_deg_ids.sub <- row.names(subset(pr_graph_test_res.sub, q_value < 0.00000001))
# write.csv(pr_graph_test_res.sub, file = "moransI_subset_cluster.csv")
# head(pr_deg_ids.sub)
#
# # collect the trajectory-variable genes into modules
# gene_module_df.sub <- find_gene_modules(plaqviewobj.cds_subset[pr_deg_ids.sub,], resolution=1e-3)
# # visualize these genes
# # here I am just pulling out genes that have high moran's i and might be helpful in the paper
# # SELECTED FOR PUBLICATIONS
# pdf("monocle3_genesoverpseudotime_seuratpartition_extended.pdf", width=7, height=6)
# plot_cells(plaqviewobj.cds_subset,
#            genes=c("MYH11", 'IGFBP2',"PPP1R14A","CNN1", "TNFRSF11B",
#                    "C7", "C3",
#                    "SERPINF1",  "FBLN1",
#                    "CXCL12", "MMP2",
#                    "FN1"), # this is faceting by the genes that are DE
#            show_trajectory_graph=FALSE,
#            label_cell_groups=F, cell_size = 1)
#
# dev.off()
#
# # recluster at higher definition
# plaqviewobj.cds_subset = cluster_cells(plaqviewobj.cds_subset, resolution=1e-2)
#
# pdf("monocle3_RNAvelocitySUBSET_seuratpartition.pdf", width=6, height=6)
# plot_cells(plaqviewobj.cds_subset,
#            color_cells_by="cluster",
#            label_groups_by_cluster=F,
#            show_trajectory_graph = T,
#            trajectory_graph_segment_size = 1,
#            label_leaves=F, # this gives a little node label (outcome)
#            label_roots = F,
#            label_branch_points = F,
#            graph_label_size = 1, # size of # in circle
#            group_label_size = 4,
#            cell_size = 1,
#            alpha = 0.5,
#            scale_to_range = T)
# dev.off()
#### STEP5A: DYNO TRAJECTORY INFERENCES ####
object_counts <- Matrix::t(as(as.matrix(plaqviewobj@assays$RNA@counts), 'sparseMatrix'))
object_expression <- Matrix::t(as(as.matrix(plaqviewobj@assays$RNA@data), 'sparseMatrix'))
object_cellinfo <- plaqviewobj@meta.data[["SingleR.calls"]]
plaqviewobj.dyno <- wrap_expression(
counts = object_counts,
expression = object_expression)
# may need to run this to clear out memory
# rm(list= ls()[!(ls() %in% c('plaqviewobj.dyno','plaqviewobj','object_cellinfo'))])
# gc()
#### STEP5B: SlingShot ####
# make sure to call up docker images
model <- infer_trajectory(plaqviewobj.dyno, "slingshot", verbose = T,
cluster_method = 'clara') # THIS IS ADDED TO REDUCE MEM REQ
# add dim reduction
model <- model %>%
add_dimred(dimred = as.matrix(plaqviewobj@reductions$umap@cell.embeddings),
expression_source = plaqviewobj.dyno$expression)
pdf("dyno_slingshot_full.pdf", width=7, height=6)
slingshot <- plot_dimred(
model,
expression_source = plaqviewobj.dyno$expression,
grouping = object_cellinfo # basically stanford@meta.data[["SingleR.calls"]]
)
saveRDS(slingshot, file = "../slingshot.rds")
slingshot
dev.off()
#### STEP5C: scorpius ####
# make sure to call up docker images
model <- infer_trajectory(plaqviewobj.dyno, "scorpius", verbose = T,
cluster_method = 'clara') # THIS IS ADDED TO REDUCE MEM REQ
# add dim reduction
model <- model %>%
add_dimred(dimred = as.matrix(plaqviewobj@reductions$umap@cell.embeddings),
expression_source = plaqviewobj.dyno$expression)
pdf("dyno_scorpius_full.pdf", width=7, height=6)
scorpius <- plot_dimred(
model,
expression_source = plaqviewobj.dyno$expression,
grouping = object_cellinfo # basically plaqviewobj@meta.data[["SingleR.calls"]]
)
saveRDS(scorpius, file = "../scorpius.rds")
scorpius
dev.off()
#### STEP5D: PAGA ####
model <- infer_trajectory(plaqviewobj.dyno, "projected_paga", verbose = T,
cluster_method = 'clara') # THIS IS ADDED TO REDUCE MEM REQ
#### PAGA: project the model ###
# add dim reduction
model <- model %>%
add_dimred(dimred = as.matrix(plaqviewobj@reductions$umap@cell.embeddings),
expression_source = plaqviewobj.dyno$expression)
paga <- plot_dimred(
model,
expression_source = plaqviewobj.dyno$expression,
grouping = object_cellinfo # basically stanford@meta.data[["SingleR.calls"]]
)
paga
saveRDS(paga, file = "../paga.rds")
#### Clean-Up Metadata ####
# show all metadata columns
names(plaqviewobj@meta.data)
# last chance to rename any
plaqviewobj@meta.data$Seurat_Clusters <- plaqviewobj@meta.data$seurat_clusters
plaqviewobj@meta.data$Author_Provided <- plaqviewobj@meta.data$manually_annotated_labels
plaqviewobj@meta.data$Seurat_with_Tabula_Ref <- plaqviewobj@meta.data$predicted.id_Tabula
# choose which ones to keep for display
plaqviewobj@meta.data <-
plaqviewobj@meta.data[, which(colnames(plaqviewobj@meta.data)
%in% c(
"Seurat_Clusters",
"scCATCH_Blood",
"scCATCH_BV",
"scCATCH_Heart",
"Author_Provided",
"SingleR.calls",
"Seurat_with_Tabula_Ref"
))]
#### STEP6: REDUCE SIZE & OUTPUT ####
plaqviewobj <- DietSeurat(plaqviewobj, counts = T, data = T, dimreducs = c('umap'))
final.file.name <- file.path(paste("../", datasetID, ".rds", sep="")) # ../ moves up one level in file
saveRDS(plaqviewobj, file = final.file.name)
plaqviewobj <- readRDS(file = final.file.name)
#### STEP7: DIFF EX GENE LIST ####
Idents(object = plaqviewobj) <- "SingleR.calls"
difflist <- Seurat::FindAllMarkers(plaqviewobj)
write_csv(difflist, file = "../diff_by_singleR.csv")
Idents(object = plaqviewobj) <- "Author_Provided"
difflist <- Seurat::FindAllMarkers(plaqviewobj)
write_csv(difflist, file = "../diff_by_author.csv")
Idents(object = plaqviewobj) <- "Seurat_Clusters"
difflist <- Seurat::FindAllMarkers(plaqviewobj)
write_csv(difflist, file = "../diff_by_seurat.csv")
Idents(object = plaqviewobj) <- "Seurat_with_Tabula_Ref"
difflist <- Seurat::FindAllMarkers(plaqviewobj)
write_csv(difflist, file = "../diff_by_Seurat_with_Tabula_Ref.csv")
#### STEP8: PRINT CELL COUNT, RAM gc ####
n <- summary(plaqviewobj$SingleR.calls)[1]
tab <- summary(as.factor(plaqviewobj$SingleR.calls))
write.csv(tab, file = paste(n, "_cell_count.csv"))
gc()
View(plaqviewobj)
#### STEP3C: SEURAT/TABULA SAPIENS LABELING ####
#### preprocess ref seurat
Idents(humanatlasref) <-  humanatlasref@meta.data[["Annotation"]]
humanatlasref <- NormalizeData(humanatlasref, verbose = T)
humanatlasref <- FindVariableFeatures(humanatlasref, selection.method = "vst", verbose = T)
DefaultAssay(plaqviewobj) <- 'RNA'
DefaultAssay(humanatlasref) <- 'RNA'
anchors <- FindTransferAnchors(reference = humanatlasref, query = plaqviewobj,
dims = 1:30)
predictions <- TransferData(anchorset = anchors, refdata = humanatlasref$Annotation,
dims = 1:30)
plaqviewobj <- AddMetaData(plaqviewobj, metadata = predictions)
#### rename transferred column metadata
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- plaqviewobj@meta.data[["predicted.id"]]
# capitalize the lettering
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <-str_to_title(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]], locale = "en")
# set to active idents
Idents(plaqviewobj) <- plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]]
#### STEP3D: recode tabula sapien labels ####
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Smooth Muscle Cell' = "SMCs")
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Pancreatic Acinar Cell' = "Panc Acinar Cell")
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Fibroblast' = "FB")
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Endothelial Cell' = "EC")
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Macrophage' = "Mø")
plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]] <- recode(plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]],
'Natural Killer Cell' = "NK")
Idents(plaqviewobj) <- plaqviewobj@meta.data[["Seurat_with_Tabula_Ref"]]
#### plot the cells
DimPlot(
plaqviewobj,
reduction = "umap",
label = TRUE,
label.size = 5,
repel = T,
# repel labels
pt.size = 1,
cols = manual_color_list) + # group.by is important, use this to call metadata separation
theme(legend.position="bottom",
legend.box = "vertical") +
ggtitle("UMAP by Cell Type") +
theme(plot.title = element_text(hjust =  0.5)) +
guides(color = guide_legend(nrow = 5))
View(plaqviewobj)
View(plaqviewobj)
plaqviewobj$Author_Provided
is.na(plaqviewobj$Author_Provided)
length(plaqviewobj$Author_Provided)
exist(plaqviewobj$Author_Provided)
exists(plaqviewobj$Author_Provided)
try(plaqviewobj$Author_Provided)
try(plaqviewobj$Author_Provided) >1
try(plaqviewobj$Author_Provided) >0
exist(plaqviewobj$Author_Provided) =T
exist(plaqviewobj$Author_Provided) =F
exist(plaqviewobj$Author_Provided) == T
exists(plaqviewobj$Author_Provided) == F
exists(plaqviewobj$Author_Provided) >1
length(plaqviewobj$Author_Provided) <0
length(plaqviewobj$Author_Provided) ==0
human_process(datasetID = "Alencar_2020")
remotes::install_github('satijalab/seurat-wrappers')
install.packages("R.utils")
remotes::install_github('satijalab/seurat-wrappers')
install_github("velocyto-team/velocyto.R")
devtools::install_github("velocyto-team/velocyto.R")
BiocManager::install("pcaMethods")
library(devtools)
install_github("velocyto-team/velocyto.R")
install.packages("RcppArmadillo")
library(devtools)
install_github("velocyto-team/velocyto.R")
library(devtools)
install_github("velocyto-team/velocyto.R")
library(devtools)
install_github("velocyto-team/velocyto.R")
library(Seurat)
library(velocyto.R)
library(SeuratWrappers)
setwd("~/Desktop")
curl::curl_download(url = 'http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom', destfile
= '~/Downloads/SCG71.loom')
# If you don't have velocyto's example mouse bone marrow dataset, download with the CURL command
curl::curl_download(url = 'http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom', destfile
= '~/Downloads/SCG71.loom')
ldat <- ReadVelocity(file = "~/Downloads/SCG71.loom")
bm <- as.Seurat(x = ldat)
View(bm)
bm@active.assay
bm@assays[["spliced"]]
bm <- as.Seurat(x = ldat)
bm <- SCTransform(object = bm, assay = "spliced")
bm <- RunPCA(object = bm, verbose = FALSE)
bm <- FindNeighbors(object = bm, dims = 1:20)
bm <- FindClusters(object = bm)
bm <- RunUMAP(object = bm, dims = 1:20)
bm <- RunVelocity(object = bm, deltaT = 1, kCells = 25, fit.quantile = 0.02)
ident.colors <- (scales::hue_pal())(n = length(x = levels(x = bm)))
names(x = ident.colors) <- levels(x = bm)
cell.colors <- ident.colors[Idents(object = bm)]
names(x = cell.colors) <- colnames(x = bm)
show.velocity.on.embedding.cor(emb = Embeddings(object = bm, reduction = "umap"), vel = Tool(object = bm,
slot = "RunVelocity"), n = 200, scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5),
cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1,
do.par = FALSE, cell.border.alpha = 0.1)
library(SCORPIUS)
install.packages("SCORPIUS
")
install.packages("SCORPIUS")
human_process(datasetID = "Li_2020")
datasetID = "Li_2020"
#### STEP1: READ DATASET DIRECTORY ####
# you must change this if your source is different
# get this to the dataprocessing - data folder in the first piece
path.to.destination <- file.path(paste("~/wm5wt@virginia.edu - Google Drive/My Drive/UVA/Grad School/Projects/PlaqView/DataProcessing/data/",
datasetID, "/source_files", sep=""))
setwd(path.to.destination)
plaqviewobj <- readRDS(file = "UNPROCESSED.rds")
plaqviewobj <- UpdateSeuratObject(plaqviewobj)
#### STEP1B: READ REFERENCE ####
humanatlasref <- LoadH5Seurat(file = "~/wm5wt@virginia.edu - Google Drive/My Drive/UVA/Grad School/Projects/PlaqView/DataProcessing/references/Tabula_sapiens_reference/TS_Vasculature.h5seurat", assays = "RNA")
srt <- NormalizeData(plaqviewobj)
expression <- t(as.matrix(srt@assays$RNA@data))
View(plaqviewobj)
expression <- Matrix::t(Matrix(plaqviewobj@assays$RNA@data, sparse = T))
plaqviewobj <- NormalizeData(plaqviewobj)
expression <- Matrix::t(Matrix(plaqviewobj@assays$RNA@data, sparse = T))
group_name <- plaqviewobj@meta.data$cell_names
group_name <- plaqviewobj@meta.data$cell_names
space <- reduce_dimensionality(expression, dist = "spearman", ndim = 3)
library(SCORPIUS)
library(Seurat)
space <- reduce_dimensionality(expression, dist = "spearman", ndim = 3)
draw_trajectory_plot(space, progression_group = group_name, contour = TRUE)
space <- reduce_dimensionality(expression, dist = "spearman", ndim = 30)
renv::status()
renv::restore
renv::restore()
renv::snapshot(())
renv::snapshot()
install.packages("symphony")
# install.packages("symphony")
plaqviewobj <- readRDS(file = "data/Alencar_2020/Alencar_2020.rds")
library(symphony)
View(plaqviewobj)
#### Library and data loading ----
library(Seurat)
library(patchwork)
library(readr)
# library(scCATCH)
library(SingleR)
library(tidyverse)
library(monocle3)
library(SeuratData)
library(magrittr)
library(ggrepel)
library(dyno) # devtools::install_github("dynverse/dyno")
library(readxl)
library(SeuratDisk)
library(celldex) # BiocManager::install("celldex")
library(symphony)
library(tidyverse)
library(data.table)
library(matrixStats)
library(Matrix)
library(bayNorm) # for transposition of sparase matrix
original_color_list <-
{c("rosybrown2",
"cadetblue1",
"lemonchiffon3",
"darkseagreen",
"skyblue3",
"thistle3",
"cadetblue3",
"darkseagreen1",
"palevioletred3",
"palevioletred1",
"darkseagreen2",
"rosybrown3",
"thistle2",
"lightsteelblue3",
"salmon1",
"palevioletred4",
"lemonchiffon4",
"cadetblue2"
)}
color_function <- colorRampPalette(original_color_list)
manual_color_list <- color_function(40) # change this if clusters >40
ref = readRDS(file = "references/Symphony_ref_data/fibroblast_atlas.rds")
View(plaqviewobj)
plaqviewobj[['RNA']]@counts
query = symphony::mapQuery(
plaqviewobj[['RNA']]@counts,
plaqviewobj@meta.data,
ref,
vars = 'samples',  # use column names from your meta_data
do_normalize = TRUE)
plaqviewobj@meta.data
unique(plaqviewobj@meta.data)
View(plaqviewobj)
query = symphony::mapQuery(
plaqviewobj[['RNA']]@counts,
plaqviewobj@meta.data,
ref,
vars = 'Author_Provided',  # use column names from your meta_data
do_normalize = TRUE)
p = plotReference(ref,
as.density = TRUE,      # plot density or individual cells
bins = 14,              # if density, nbins parameter for stat_density_2d
bandwidth = 1,        # if density, bandwidth parameter for stat_density_2d
title = "Symphony Reference: 10x PBMCs",    # Plot title
color.by = 'cell_type', # metadata column name for cell type labels
celltype.colors = pbmc_colors, # custom color palette
show.legend = TRUE,     # Show cell type legend
show.labels = TRUE,     # Show cell type labels
show.centroids = FALSE) # Plot soft cluster centroid locations)
colnames(query$umap) = c('UMAP1', 'UMAP2')
umap_labels = cbind(query$meta_data, query$umap)
library(symphony)
plaqviewobj <- readRDS(file = "data/Alencar_2020/Alencar_2020.rds")
ref = readRDS(file = "references/Symphony_ref_data/fibroblast_atlas.rds")
query = symphony::mapQuery(
plaqviewobj[['RNA']]@counts,
plaqviewobj@meta.data,
ref,
vars = 'Author_Provided',  # use column names from your meta_data
do_normalize = TRUE)
suppressPackageStartupMessages({
source('libs.R') # imports
source('utils.R') # color definitions and plotting functions
})
suppressPackageStartupMessages({
source('symphonyR/libs.R') # imports
source('symphonyR/utils.R') # color definitions and plotting functions
})
setwd("/Volumes/GoogleDrive-115504944321605412484/My Drive/UVA/Grad School/Projects/PlaqView/DataProcessing")
source('symphonyR/libs.R') # imports
source('symphonyR/utils.R') # color definitions and plotting functions
source('symphony-main/vignettes/libs.R') # imports
devtools::install_github('immunogenomics/singlecellmethods')
devtools::install_github('immunogenomics/singlecellmethods')
suppressPackageStartupMessages({
source('symphony-main/vignettes/libs.R') # imports
source('symphony-main/vignettes/utils.R') # color definitions and plotting functions
})
install.packages("ggthemes")
plaqviewobj <- readRDS(file = "data/Alencar_2020/Alencar_2020.rds")
ref = readRDS(file = "references/Symphony_ref_data/fibroblast_atlas.rds")
query = symphony::mapQuery(
plaqviewobj[['RNA']]@counts,
plaqviewobj@meta.data,
ref,
vars = 'Author_Provided',  # use column names from your meta_data
do_normalize = TRUE)
colnames(query$umap) = c('UMAP1', 'UMAP2')
query$umap
query
View(query)
fig.size <- function (height, width) {
options(repr.plot.height = height, repr.plot.width = width)
}
p = plotReference(ref,
as.density = TRUE,      # plot density or individual cells
bins = 14,              # if density, nbins parameter for stat_density_2d
bandwidth = 1,        # if density, bandwidth parameter for stat_density_2d
title = "Symphony Reference: 10x PBMCs",    # Plot title
color.by = 'cell_type', # metadata column name for cell type labels
celltype.colors = pbmc_colors, # custom color palette
show.legend = TRUE,     # Show cell type legend
show.labels = TRUE,     # Show cell type labels
show.centroids = FALSE) # Plot soft cluster centroid locations)
query = symphony::mapQuery(
plaqviewobj[['RNA']]@counts,
plaqviewobj@meta.data,
ref,
vars = 'Author_Provided',  # use column names from your meta_data
do_normalize = TRUE,
do_umap = TRUE)
colnames(query$umap) = c('UMAP1', 'UMAP2')
query
library(CIPR)
devtools::install_github("atakanekiz/CIPR-Package", build_vignettes = T)
allmarkers <- FindAllMarkers(plaqviewobj)
avgexp <- AverageExpression(plaqviewobj)
library(Seurat)
allmarkers <- FindAllMarkers(plaqviewobj)
avgexp <- AverageExpression(plaqviewobj)
plaqviewobj <- LogNormalize(plaqviewobj)
plaqviewobj <- NormalizeData(plaqviewobj)
avgexp <- AverageExpression(plaqviewobj)
allmarkers <- FindAllMarkers(plaqviewobj)
# Plot summarizing top scoring references per cluster (logFC comparison)
CIPR(input_dat = allmarkers,
comp_method = "logfc_dot_product",
reference = "immgen",
plot_ind = F,
plot_top = T)
library(CIPR)
# Plot summarizing top scoring references per cluster (logFC comparison)
CIPR(input_dat = allmarkers,
comp_method = "logfc_dot_product",
reference = "ENCODe",
plot_ind = F,
plot_top = T)
# Plot summarizing top scoring references per cluster (logFC comparison)
CIPR(input_dat = allmarkers,
comp_method = "logfc_dot_product",
reference = "blueprint",
plot_ind = F,
plot_top = T)
# Start the clock!
ptm <- proc.time()
plaqviewobj <- NormalizeData(plaqviewobj)
allmarkers <- FindAllMarkers(plaqviewobj)
avgexp <- AverageExpression(plaqviewobj)
# Plot summarizing top scoring references per cluster (logFC comparison)
CIPR(input_dat = allmarkers,
comp_method = "logfc_dot_product",
reference = "blueprint",
plot_ind = F,
plot_top = T)
# Stop the clock
proc.time() - ptm
# Plots for individual clusters
CIPR(input_dat = allmarkers,
comp_method = "logfc_dot_product",
reference = "immgen",
plot_ind = T,
plot_top = F)
